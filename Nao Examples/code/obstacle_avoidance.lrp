;;; Obstacle Avoidance program for the Nao;;; It works well with 1 or 2 hz(machine ObstacleAvoidance	(var forwardSpeed := [0.1])	(var turnSpeed := [0.1])	(var minDistance := [0.5])	(var leftData := ['Device/SubDeviceList/US/Left/Sensor/Value'])	(var rightData := ['Device/SubDeviceList/US/Right/Sensor/Value'])	(state init 		(onentry [robot serviceALMotion wakeUp.				robot serviceALSonar subscribe: 'ObstacleAvoidance'.				robot serviceALRobotPosture async goToPosture: 'Stand' speed: 0.8]))	(state forward		(onentry [ 			robot serviceALMotion 				moveSpeedX: forwardSpeed speedY: 0 speedTheta: 0]))	(state avoid 		(machine avoid						(state stop				(onentry [					robot serviceALMotion async stopMove]))			(state decide)			(state turnLeft				(onentry [					robot serviceALMotion 						moveSpeedX: 0 speedY: 0 speedTheta: turnSpeed]))			(state turnRight				(onentry [					robot serviceALMotion 						moveSpeedX: 0 speedY: 0 speedTheta: turnSpeed negated]))						(on [robot serviceALMotion lastProcess isFinished] stop -> decide)			(on obstacleLeft decide -> turnRight)			(on obstacleRight decide -> turnLeft)			(on noObstacleLeft turnRight -> stop)			(on noObstacleRight turnLeft -> stop)						(event obstacleLeft				 [(robot serviceALMemory getData: leftData) < 0.5])			(event obstacleRight				 [(robot serviceALMemory getData: rightData) < 0.5])			(event noObstacleLeft 				[(robot serviceALMemory getData: leftData) >0.5])			(event noObstacleRight 				[(robot serviceALMemory getData: rightData) > 0.5])		)		(onentry (spawn avoid stop))	)	(on [robot serviceALRobotPosture lastProcess isFinished] init -> forward)	(on obstacle forward -> avoid)	(on noObstacle avoid -> forward) 		(event obstacle 		[(robot serviceALMemory getData: leftData) < 0.5			or:[(robot serviceALMemory getData: rightData) < 0.5]])	(event noObstacle		[(robot serviceALMemory getData: leftData) > 0.5			and: [(robot serviceALMemory getData: rightData) > 0.5]]))(spawn ObstacleAvoidance init)