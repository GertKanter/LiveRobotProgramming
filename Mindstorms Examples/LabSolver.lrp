;;; New program created by johanfabry on 17 December 2015;;; Solver for the labyrinth in the robotics lab of the DCC(var white := [6])(var red :=[5])(var blue := [1])(var lightsensor := [robot sensor3])(var ultsensor := [robot sensor2])(var rightmotor := [robot motorA])(var leftmotor := [robot motorD])(var headmotor := [robot motorB])(var turnspeed := [10])(var intersect :=[false])(machine rhr	(state line		(machine linefollow			(state offline				(onentry [rightmotor startAtSpeed: turnspeed])				(onexit [rightmotor stop]))			(state online				(onentry [leftmotor startAtSpeed: turnspeed])				(onexit [leftmotor stop]))			(on readline offline -> online)			(on noline online ->offline)			(event readline [lightsensor read = blue])			(event noline [lightsensor read = white])			(event readred [lightsensor read = red])			(on readred *-> eol)			(state eol (onentry [intersect := true])))		(onentry (spawn linefollow online)))	(on detinter line -> intercenter)	(event detinter [intersect])	(state intercenter		(onentry [			intersect := false.			rightmotor clearCount.			rightmotor startAtSpeed: turnspeed/2.			leftmotor startAtSpeed: turnspeed/2])		(onexit [rightmotor stop. leftmotor stop.]))	(on interdelta  intercenter -> intersection)	(event interdelta [rightmotor getCount > 75])	(var inturn :=[false])	(var distances := [{0 . 0 . 0}])	(state intersection		(machine lookaround			(state right				(onentry [					headmotor  moveToAbsolutePositionSpeed: turnspeed								position: 100 brake: false] )				(onexit [distances at: 1 put: ultsensor read]))			(state front				(onentry [					headmotor  moveToAbsolutePositionSpeed: turnspeed								position: 0 brake: false] )				(onexit [distances at: 2 put: ultsensor read]))			(state left				(onentry [					headmotor  moveToAbsolutePositionSpeed: turnspeed								position: -100 brake: false] )				(onexit [distances at: 3 put: ultsensor read]))			(state pub				(onentry [					headmotor  moveToAbsolutePositionSpeed: turnspeed								position: 0 brake: false.					inturn := true] ))			(ontime 1000 right -> front)			(ontime 1000  front -> left)			(ontime 1000  left -> pub))		(onentry (spawn lookaround right)))	(on goturn intersection -> turn)	(event goturn [inturn])	(state turn		(machine turnalgo			(var turndist := [150])			(var direction :=[				(distances at: 1) > 200 ifTrue: [$E]					ifFalse: [(distances at: 2) > 200 ifTrue:[$N]						ifFalse: [(distances at: 3) > 200 ifTrue: [$W]							ifFalse: [$S]]]])			(event north [direction = $N])			(event south [direction = $S])			(event east [direction = $E])			(event west [direction =$W])			(state init				(onentry [					leftmotor clearCount. rightmotor clearCount. ]))			(on north init -> noturn)			(on south init ->oneighty)			(on east init -> righturn)			(on west init -> lefturn)			(state noturn)			(state lefturn				(onentry [					rightmotor  moveToAbsolutePositionSpeed: turnspeed							position: turndist brake: false.					leftmotor  moveToAbsolutePositionSpeed: turnspeed							position: turndist negated brake: false.] ))			(state righturn				(onentry  [					leftmotor  moveToAbsolutePositionSpeed: turnspeed							position: turndist brake: false.					 rightmotor moveToAbsolutePositionSpeed: turnspeed							position: turndist negated brake: false.] ))			(state oneighty				(onentry [rightmotor  moveToAbsolutePositionSpeed: turnspeed							position: turndist* 2  brake: false.					leftmotor  moveToAbsolutePositionSpeed: turnspeed							position: turndist * 2 negated brake: false.]))			(ontime 2500 righturn -> exit)			(ontime 2500 lefturn -> exit)			(ontime 200 noturn -> exit)			(ontime 4000 oneighty -> exit)			(state exit (onentry [leftmotor  moveToRelativePositionSpeed: turnspeed							 degrees: 70 brake: false]))			(ontime 1000 exit -> end)			(state end (onentry [inturn := false])))		(onentry (spawn turnalgo init)))	(on turndone turn ->line)	(event turndone [inturn not])	)(spawn rhr line)